{"name":"Glbench27-nacl","tagline":"","body":"## Porting to Chrome Native Client (NaCl) ##\r\n\r\n#### Overview of Document ####\r\nThis document will outline the process of porting a C++ application to Chrome Native Client (NaCl).\r\nThe documentation on NaCl can be confusing so I will try to clarify what I have been able to learn about how NaCl works\r\nand what is required to get an application up and running within Chrome.\r\n\r\n#### Table of Contents ####\r\n\r\n- [Native Client and Portable Native Client](#pnaclvnacl)\r\n- [Native Client Application Structure](#naclappstruct)\r\n- [Visual Studio and Toolchain](#vs_tool)\r\n- [GLBenchmark Application Outline](#glbappoutline)\r\n- [NaCl Messaging](#naclmessage)\r\n- [NaCl Instance and OpenGL Setup](#instance_gl_setup)\r\n- [NaCl Threads and SwapBuffers](#naclthreads)\r\n- [NaCl File I/O](#naclfileio)\r\n- [Asset Management](#assetman)\r\n- [Converting to NaCl Chrome App](#convertchromeapp)\r\n- [Debugging and Logging](#debuglog)\r\n\r\n#### <a id=\"pnaclvnacl\"/> Native Client and Portable Native Client ####\r\n\r\nAs outlined [here](https://developer.chrome.com/native-client/nacl-and-pnacl) there is a distinction made between\r\nPortable Native Client (PNaCl) and Native Client (NaCl). The source code of the module does not vary between the two\r\n(although there are some restrictions in PNaCl) but there there are a number of differences regarding the toolchain.\r\nFor this project, I have used the standard Native Client toolchain as (although Google suggests using PNaCl) the PNaCl\r\ntoolchain is much less stable and less clearly documented.\r\n\r\n#### <a id=\"naclappstruct\"/> Native Client Application Structure ####\r\n\r\nThe structure of a NaCl application involves 4 main components. These are:\r\n\r\n- HTML file (`.html`)\r\n- JavaScript file (`.js`)\r\n- NaCl manifest (`.nmf`)\r\n- NaCl module (`.nexe`)\r\n\r\nThe HTML file and JavaScript file are the entry point to the NaCl module and house traditional web code. The NaCl manifest\r\nfile specifies the properties of your module and the NaCl module itself contains your compiled native code in `.nexe` format.\r\n\r\nYou can get a description of each of these items from Google \r\n[here](https://developer.chrome.com/native-client/devguide/coding/application-structure). I will detail the composition of\r\neach of these files within the GLBenchmark example:\r\n\r\nAs explained in the documentation, the HTML file must contain an `<embed>` element that triggers the loading of the \r\nNaCl module.\r\n\r\nThe `<embed>` element within the GLBenchmark example (let's just call it GLB) is as follows:\r\n```html\r\n<embed id=\"glbench_nacl_vs10\"\r\n           width=1280 height=720\r\n           src=\"newlib/glbench_nacl_vs10.nmf\"\r\n           type=\"application/x-nacl\" />\r\n```\r\nAs you can see, we are specifying the location of the NaCl manifest file as well as specifying that the type of the embed is\r\n`application/x-nacl`. Finally, we outline both the width and height of the area that the NaCl module will manage in the \r\nwebpage.\r\n\r\nThe NaCl manifest (`.nmf`) file for this project is:\r\n```\r\n{\r\n  \"files\": {},\r\n  \"program\": {\r\n    \"x86-64\": {\r\n      \"url\": \"glbench_nacl_vs10_64.nexe\"\r\n    }\r\n  }\r\n}\r\n```\r\nThe program component specifies to location of the compiled `.nexe` file for each architecture. In this case, there only\r\nexists one `.nexe` for the 64-bit x86 architecture. A more in-depth look at `.nmf` files can be found \r\n[here](https://developer.chrome.com/native-client/reference/nacl-manifest-format).\r\n\r\nThe NaCl module is where all of the native code lives. When compiled we have a `.nexe` file. In order for native code to be\r\ncompiled into a NaCl module, there are a number of components that must exist in the code.\r\n\r\n- a factory function `CreateModule()`\r\n- a Module class (derived from `pp::Module`)\r\n- an Instance class (derived from `pp::Instance`)\r\n\r\nThese components are outlined in more depth [here](https://developer.chrome.com/native-client/devguide/coding/application-structure#native-client-modules-a-closer-look).\r\n\r\nFor GLB, all of the NaCl related code exists in a C++ file called `nacl_main.cpp`.\r\nAn outline of this file with these components present is:\r\n```cpp\r\n#include \"ppapi/cpp/instance.h\"\r\n#include \"ppapi/cpp/module.h\"\r\n\r\n\r\n// Instance class that extends pp::Instance\r\nclass GLBenchInstance : public pp::Instance {\r\npublic:\r\n  explicit GLBenchInstance(PP_Instance instance)\r\n    : pp::Instance(instance) {}\r\n\r\n  virtual ~GLBenchInstance() {}\r\n\r\n};\r\n\r\n// Module class that extends pp::Module\r\nclass GLBenchModule : public pp::Module {\r\npublic:\r\n  GLBenchModule() : pp::Module() {}\r\n  virtual ~GLBenchModule() {}\r\n\r\n  virtual pp::Instance* CreateInstance(PP_Instance instance) {\r\n    return new GLBenchInstance(instance);\r\n  }\r\n\r\n};\r\n\r\nnamespace pp {\r\n  // Factory method for creating module\r\n  Module* CreateModule() {\r\n    return new GLBenchModule();\r\n  }\r\n}\r\n```\r\nThe instance created corresponds to the space on the webpage that is managed by the NaCl module. The NaCl module class\r\nis used by the browser to create a module object that is the main binding point between the browser and the NaCl module.\r\nAn instance is created by the module whenever there is an `<embed>` element within the webpage that references the module.\r\n\r\n#### <a id=\"vs_tool\"/> Visual Studio and Toolchain ####\r\n\r\nFor developing NaCl applications, there are a couple of different tools available. After downloading the \r\n[NaCl SDK](https://developer.chrome.com/native-client/sdk/download), you can either:\r\n\r\n- Use a `makefile` and build your project manually\r\n- Install Google's provided Visual Studio 2010 plugin\r\n\r\n[Here](https://developer.chrome.com/native-client/devguide/devcycle/building) is the provided documentation on building\r\na Native Client module. It largely focuses on how to build a PNaCl `.pexe` and so will be largely ignored for this section.\r\n\r\n**Note:** The Visual Studio plugin does not have stable PNaCl support and I found that the only reliable way\r\nto build a `.pexe` was using makefiles (see the `GLBenchmark_2_7_0/Projects/nacl/PNaCl Make` folder for an example)\r\n\r\nThe easiest method, and the method I took, was to install and use the Visual Studio 2010 plugin. Documentation on\r\ninstalling the plugin can be found [here](https://developer.chrome.com/native-client/devguide/devcycle/vs-addin).\r\nAn item of note is that the compiled application can only be run in debug mode from within Visual Studio and that a server\r\nmust already be running before it can do so (the default is `http://localhost:5103`)\r\n\r\n#### <a id=\"glbappoutline\"/> GLBenchmark Application Outline ####\r\n\r\nHere is very quick outline of the structure of the GLBenchmark application used in this example. I have tried to gloss over\r\nas many details as possible but some understanding of the structure of the application will hopefully aid in\r\nunderstanding the porting process.\r\n\r\nThe GLBenchmark application looks to run a series of tests and measure the performance in order to output results.\r\nWith this being the case, the basic application loop consists of the following steps:\r\n\r\n1. Setup the GLB application\r\n2. Add a number of tests to be run\r\n3. Select a test\r\n4. Initialize the test and run it\r\n5. Finish the test and output results\r\n6. Continue to run tests until there are none left\r\n7. Close application\r\n\r\nThe codebase for GLB is composed of an `GLB::Application` class that handles all of the rendering, animation and other\r\ndetails regarding running a test. This class contains no platform-specific code and does the majority of the work. It\r\nprovides the ability to run select, initialize, run and output the results of any specified test.\r\n\r\nIn addition, for each platform (i.e. Android, OSX, NaCl) that the application supports, there is a platform-specific set of\r\ncode that includes the entry to the main loop and the main application loop itself. For the port of GLBenchmark, all of the\r\n`GLB::Application` code was left untouched and a new set of NaCl specific code was added. This code had to encompass all\r\nfunctionality outside of that provided by `GLB::Application`, namely setting up the application, handling input, initializing\r\nassets and communicating with the user.\r\n\r\n#### <a id=\"naclmessage\"/> NaCl Messaging ####\r\n\r\nSince Native Client is a component that exists within a webpage, there is a need to communicate between the webpage, \r\ngenerally using JavaScript, and the NaCl module. Google provides an interface for doing just that. It is outlined\r\n[here](https://developer.chrome.com/native-client/devguide/coding/message-system).\r\n\r\nWithin this project, messaging between the NaCl module and the user facing webpage has been used to communicate the user's\r\nchoice of test to the NaCl module as well as to communicate the NaCl module's status to be displayed by the webpage.\r\n\r\nThe relevant messaging function within the NaCl module is:\r\n\r\n```cpp\r\n// Handle message sent from JavaScript\r\nvirtual void HandleMessage(const pp::Var& var_message) {\r\n  // Ignore the message if it is not a string.\r\n  if (!var_message.is_string())\r\n    return;\r\n  // Convert message to a string\r\n  PostMessage(\"Message received\");\r\n  PostMessage(var_message);\r\n  std::string message_str = var_message.AsString();\r\n\r\n  // If the message received is 'Start', then setup the GLB application on application thread\r\n  if (message_str == \"Start\") \r\n  {\r\n    glb_app_thread.message_loop().PostWork(m_callback_factory.NewCallback(&GLBenchInstance::SetupGLBApplication)); \r\n    return;\r\n  }\r\n  // If the message is 'NextTest' tell window that next test command has been started\r\n  else if (message_str == \"NextTest\")\r\n  {\r\n    PostMessage(\"Moving to next test\");\r\n    // This crashes somewhere down the line\r\n    m_wnd->handle_cmd(1);\r\n  }\r\n  // Set onscreen or offscreen value for trex test\r\n  else if (message_str == \"trex_on\")\r\n  {\r\n    m_onscreen_test = true;\r\n  }\r\n  else if (message_str == \"trex_off\")\r\n  {\r\n    m_onscreen_test = false;\r\n  }\r\n}\r\n```\r\n\r\nThis function processes the message sent from the webpage and parses it to either start the application, move to the next\r\ntest or start the default TRex test in onscreen or offscreen mode.\r\n\r\nThe messaging function within the JavaScript is:\r\n\r\n```javascript\r\n// Handle message sent from NaCL module ( using pp::Instance.PostMessage())\r\n// Display to console\r\nfunction handleMessage(message_event) {\r\n  // Display to console\r\n  console.log(message_event.data);\r\n  // Parse incoming message string and update status with any messages prefixed by 'GLB'\r\n  var newStr = new String(message_event.data);\r\n  if (newStr.charAt(0) == 'G' && newStr.charAt(1) == 'L' && newStr.charAt(2) == 'B') {\r\n    updateStatus(message_event.data);\r\n  } else if (newStr == \"ExitModule\") {\r\n    // ExitModule message ends NaCl module\r\n    endModule();\r\n  }\r\n}\r\n```\r\n\r\nThis function logs any output from the NaCl module to the log and calls an `updateStatus()` function if the message is\r\nprefixed by `GLB`.\r\n\r\n\r\n#### <a id=\"instance_gl_setup\"/> NaCl Instance and OpenGL Setup ####\r\n\r\nNow we will look at the intial setup of a NaCl instance as well as how to create a graphics context.\r\nOnce a NaCl instance has been created, any initialization code can be done in the `init` function. This function has\r\nthe prototype:\r\n\r\n```cpp\r\nvirtual bool Init(uint32_t argc, const char* argn[], const char* argv[])\r\n```\r\n\r\nNaCl does not have allow direct access to the graphics context and in fact, there is no EGL in NaCl. All of the graphics\r\nsetup is done using Google's PPAPI using a `pp::Graphics3D` object. In order to create the context and use OpenGL functions,\r\nyou must include `ppapi/lib/gl/gles2/gl2ext_ppapi.h` and `ppapi/cpp/graphics_3d.h`. Within the GLB code, in `nacl_main.cpp`\r\nthere is an `InitGL` function:\r\n\r\n```cpp\r\n// Sets up Context for drawing and makes it available globally\r\nbool InitGL(int32_t new_width, int32_t new_height) {\r\n  // Attempt to initialize OpenGL using PPAPI\r\n  if (!glInitializePPAPI(pp::Module::Get()->get_browser_interface())) \r\n  {\r\n    PostMessage(\"Unable to initialize GL PPAPI!);\r\n    return false;\r\n  }\r\n\r\n  // Define attributes for graphics context\r\n  const int32_t attrib_list[] = {\r\n    PP_GRAPHICS3DATTRIB_DEPTH_SIZE, 24,\r\n    PP_GRAPHICS3DATTRIB_WIDTH, new_width,\r\n    PP_GRAPHICS3DATTRIB_HEIGHT, new_height,\r\n    PP_GRAPHICS3DATTRIB_NONE\r\n  };\r\n\r\n  // Create new context with given attribute list\r\n  m_context = pp::Graphics3D(this, attrib_list);\\\r\n  // Set global context to be current context for egllibs\r\n  egllib_context = m_context;\r\n  // Attempt to bind 3d context\r\n  if (!BindGraphics(m_context)) \r\n  {\r\n    fprintf(stderr, \"Unable to bind 3d context!\\n\");\r\n    m_context = pp::Graphics3D();\r\n    glSetCurrentContextPPAPI(0);\r\n    return false;\r\n  }\r\n\r\n  glSetCurrentContextPPAPI(m_context.pp_resource());    \r\n\r\n  return true;\r\n}\r\n```\r\n\r\nMore information about setting up OpenGL in NaCl can be found [here](https://developer.chrome.com/native-client/devguide/coding/3D-graphics)\r\n\r\nThe fact that there is no EGL present within NaCl (it is obscured by `pp::Graphics3D`) can cause trouble when dealing with\r\na codebase that uses EGL. In order to handle this problem in the GLB example, I was forced to implement the EGL header and\r\nfunctions. This involved creating a `include\\egl.h` file that specified the following EGL functions:\r\n\r\n```cpp\r\n// EGL function prototypes - to be overwritten using NaCl\r\nunsigned int eglGetConfigAttrib(void * display, void * config, unsigned int attribute, int * value);\r\nunsigned int eglGetConfigAttrib(void * display, void * config, unsigned int attribute, unsigned int * value);\r\nunsigned int eglGetConfigs(void * display, void ** configs, unsigned int config_size, unsigned int * num_config);\r\nchar const * eglQueryString(void* display, unsigned int name);\r\n```\r\n\r\nThese were then implemented (without full functionality) in order to not break the existing source code. Full functionality\r\nwas not required because `pp::Graphics3D` effectively replaces EGL. The partial implementations are found below:\r\n\r\n```cpp\r\n#include <EGL/egl.h>\r\n#include \"ppapi/lib/gl/gles2/gl2ext_ppapi.h\"\r\n#include \"ppapi\\cpp\\graphics_3d.h\"\r\n#include \"ppapi\\c\\ppb_graphics_3d.h\"\r\n\r\n// Global Graphics3D context to be set to current context by main instance\r\npp::Graphics3D egllib_context;\r\n\r\n// Override EGL functions using NaCl Graphics3D API\r\n// Handle both case where value is unsigned or signed\r\nunsigned int eglGetConfigAttrib(void * display, void * config, unsigned int attribute, unsigned int * value) {\r\n  return eglGetConfigAttrib( display, config, attribute, (int*)value);\r\n}\r\n\r\nunsigned int eglGetConfigAttrib(void * display, void * config, unsigned int attribute, int * value) {\r\n  int32_t attrib_list[] = {attribute, 0};\r\n  PP_Resource context = glGetCurrentContextPPAPI();\r\n  int32_t return_value = egllib_context.GetAttribs(attrib_list);\r\n  return (int) return_value;\r\n}\r\n\r\n// Does this need to be implemented or can we return dummy information?\r\nunsigned int eglGetConfigs(void * display, void ** configs, unsigned int config_size, unsigned int * num_config) {\r\n  return (int) 0;\r\n}\r\n\r\nchar const * eglQueryString(    void* display, unsigned int name) {\r\n  return \"\";\r\n}\r\n```\r\n\r\n#### <a id=\"naclthreads\"/> NaCl Threads and SwapBuffers ####\r\n\r\nWhen working with NaCl there are some important things to node when trying to render or perform I/O. Each Chrome tab runs as\r\nit's own process and has it's own main thread. Once a NaCl module is started, it is run in its own, sandboxed, process that\r\nis seperate from the main Chrome process that is associated with each tab. The NaCl module runs it's own main thread as well.\r\nCommunication between both the NaCl main thread and the Chrome main thread are handled using PPAPI calls.\r\n\r\nThis all pertains to rendering 3D graphics because we must use a special function, called from out NaCl thread, in order to\r\nswap buffers in the Chrome main thread in order for anything to be displayed on the screen.\r\n\r\nThe documentation for this function can be found [here](https://developer.chrome.com/native-client/pepper_stable/c/struct_p_p_b___graphics3_d__1__0#a293c6941c0da084267ffba3954793497)\r\n\r\nThis function is non-blocking and requires that a callback function is provided. In short, it performs some work on the\r\nChrome main thread and then once this is complete, it calls the provided callback function on the Native Client thread.\r\nI found that this behaviour makes handling the main render loop much more complicated than it needs to be.\r\n\r\nHere is an image (from Google) of the expected communication between the Chrome and NaCl threads:\r\n\r\n![](https://developer.chrome.com/native-client/images/3d-graphics-render-loop.png?raw=true)\r\n\r\nLet's now look at how I went about handling this issue in the GLB example.\r\n\r\nLooking at the main application loop for GLB used in the linux version of GLB we can see that it has the following form:\r\n\r\n1. Initialize and create GLB application\r\n2. Loop over list of selected tests\r\n3. Select test and render loading screen\r\n    - Make a call to swapbuffers after rendering loading screen\r\n4. Loop while running current test to render and animate\r\n    - Make a call to swapbuffers for each loop\r\n\r\nYou can see the full code for the main loop [here](https://gist.github.com/nicolaslangley/eeb6dc8c5411c2ef8782)\r\n\r\nThe calls to swapbuffer made in the linux version are assumed to be blocking on the main application thread. However,\r\nwithin the Native Client paradigm, the `pp::Graphics3D::SwapBuffers` call is non-blocking on the Native Client thread.\r\nThis requires a revision of the main application loop to accomodate this and involves splitting up the main loop into a\r\nnumber of functions that can be passed as callback functions to `pp::Graphics3D::SwapBuffers`. The set of functions that\r\nprovide analogous functionality to the linux main loop above are:\r\n\r\n- `SetupGLBApplication()`\r\n    - Creates graphics context\r\n    - Sets up GLB application and parses application parameters\r\n    - Calls `SetupTests()`\r\n- `SetupTests()`\r\n    - This function handles the setup portion of the main loop\r\n    - Chooses which test to run\r\n    - Renders loading screen\r\n    - Makes a call to `pp::Graphics3D::SwapBuffers` with `InitTest()` as callback\r\n    - If no test is chosen, calls `ExitTests()`\r\n- `InitTest()`\r\n    - Initialize the test within the GLB application\r\n    - Renders running screen\r\n    - Makes a call to `pp::Graphics3D::SwapBuffers` with `RunTest()` as callback\r\n- `RunTest()`\r\n    - Performs animation and rendering of the current test\r\n    - Continually calls `pp::Graphics3D::SwapBuffers` with itself as callback until test is finished\r\n    - This mimics the test loop found in the Linux version\r\n    - When test is finished, calls `EndTest()`\r\n- `EndTest()`\r\n    - Handles finishing up of currently running test\r\n    - Calls `SetupTests()`\r\n- `ExitTest()`\r\n    - Cleans up GLB application\r\n    - Outputs results and exits NaCl module\r\n\r\nThe source for the above functions can be found [here](https://gist.github.com/nicolaslangley/b0c03840b432c2db3259)\r\n\r\n**Note:** All functions passed as callbacks to a function must have `int32_t` as parameter (e.g. `void InitTest(int32_t)`)\r\n\r\nThe behaviour of `pp::Graphics3D::SwapBuffers` requires the use of multiple functions in place of one contiguous loop in a\r\ntraditional main function. For this example, it was possible to make this modification fairly seamlessly, it is something to\r\nconsider when looking at applications that may require more complex usage of `pp::Graphics3D::SwapBuffers`.\r\n\r\nRendering isn't the only behaviour within Native Client that requires special care. `pp::Graphics3D::SwapBuffers` is \r\nnon-blocking on the Native Client main thread because you **cannot block** on the main NaCl thread. This leads to a\r\nnumber of issues when trying to perform some basic tasks (e.g. C style File I/O).\r\n\r\nThe GLB codebase makes extensive use of blocking calls and so In order to find a way around the restriction of being unable\r\nto block on the main Native Client thread, I had to create a second worker thread that performed all meaningful GLB-related\r\ntasks.\r\n\r\nCreating a thread within your NaCl module can be done using the `pp::SimpleThread` class.\r\nTo create and start new thread:\r\n\r\n```cpp\r\n#include \"ppapi/utility/threading/simple_thread.h\"\r\npp::SimpleThread glb_app_thread;\r\nglb_app_thread.Start();\r\n```\r\n\r\nTo close the thread (in GLB this is in the instance destructor) use `glb_app_thread.Join();`\r\n\r\nIn order to assign work to the worker thread, you have to use the [`pp::MessageLoop`](https://developer.chrome.com/native-client/pepper_stable/cpp/classpp_1_1_message_loop) \r\nclass to post work to the thread. An example of this is posting the `SetupGLBApplication()` function to be run on the\r\n`glb_app_thread`:\r\n\r\n```cpp\r\nglb_app_thread.message_loop().PostWork(m_callback_factory.NewCallback(&GLBenchInstance::SetupGLBApplication));\r\n```\r\n\r\n**Note:** In this example, I elected to run the entire GLB application on a worker background thread and only handle basic\r\ncommunication between the main Native Client thread and the Chrome main thread. This was due to the use of blocking I/O\r\ncalls present within the GLB application.\r\n\r\n#### <a id=\"naclfileio\"/> NaCl File I/O ####\r\n\r\nThe previous section offers a nice segue into how File I/O is done in Native Client. There are two distinct facilities\r\navailable for performing File I/O. Firstly, you can use the [`pp::FileIO`](https://developer.chrome.com/native-client/pepper_stable/cpp/classpp_1_1_file_i_o)\r\nclass to perform non-blocking File I/O within the main Native Client thread. An in depth look into how to use this API is\r\nprovided [here](https://developer.chrome.com/native-client/devguide/coding/file-io)\r\n\r\nGoogle also provides the ability to perform traditional blocking I/O by way of the `nacl_io` library. This library provides\r\naccess to traditional C-style File I/O (i.e. `fopen`, `fread`, etc.) that allow for the use of more traditional blocking I/O.\r\nAn explanation of how this library works is available [here](https://developer.chrome.com/native-client/devguide/coding/nacl_io).\r\nThe examples all deal with a C application and setup, so I will detail how I used the library within the GLB application.\r\n\r\nIn order to setup the `nacl_io` library, you must include both `nacl_io/nacl_io.h` and `sys/mount.h`. We can then\r\ninitialize the library by making the following call:\r\n\r\n```cpp\r\nnacl_io_init_ppapi(this->pp_instance(), pp::Module::Get()->get_browser_interface());\r\n```\r\n\r\nAll File I/O within NaCl requires a file system to be active. Since we are operating within the browser, there is no\r\naccess to the system file system, but we can use the HTML5 Persistent Storage to read and write files from. In order to use\r\na file system within NaCl, and `nacl_io` specifically, we must mount the desired file system using `mount`. This is done\r\nas follows:\r\n\r\n```cpp\r\n// Unmount default file system and mount persistent HTML5 filesystem\r\numount(\"/\");\r\nint mount_result = mount(\"\",\"/persistent\",\"html5fs\",0,\"type=PERSISTENT,expected_size=1048576\");\r\n```\r\n\r\n**Note:** while `nacl_io` and the `pp::FileIO` API use the same file system, they are set up differently\r\n\r\nOnce we have mounted the filesystem and initialized the `nacl_io` library, it is possible to use traditional C-style file I/O\r\ncalls throughout the application. The only requirement is that these blocking calls cannot occur on the main Native Client\r\nthread. For details on this see [the threading section](#naclthreads)\r\n\r\n#### <a id=\"assetman\"/> Asset Management ####\r\n\r\nIf the program being ported as a large number of assets required, there are a couple of different options for obtaining them\r\nfor use in your Native Client application. If you are able to host the required files on your own webserver, you can use\r\nthe NaCl [URLLoader API](https://developer.chrome.com/native-client/pepper_stable/cpp/classpp_1_1_u_r_l_loader) to download\r\nthem and save them to the HTML5 persistent storage. Details on how to do this can be found [here](https://developer.chrome.com/native-client/devguide/coding/url-loading)\r\n\r\nWith the GLB example, I took a different approach. In order to read and write to files, they must be present in the HTML5\r\npersistent file storage that is mounted and used by the `nacl_io` library. Instead of loading and downloading URLs witin the\r\nNative Client module, I instead chose to load the HTML5 persistent filesystem and copy the relevant files within JavaScript\r\nas part of the webpage that hosts the Native Client module.\r\n\r\nIn order to do this, I relied on the user specifying the location of the relevant asset files on their local machine.\r\n\r\n**Note:** After I detail more about how to package the application into a Chrome App, I will show how to bundle the assets\r\nso that no user input is required\r\n\r\nChrome supports the `FileSystem API` (for more see [here](http://www.html5rocks.com/en/tutorials/file/filesystem/)) and this\r\ncan be used to read and write files to HTML5 persistent storage.\r\n\r\nTo present the user with the option of selecting a directory for uploading, you must add an input element to your HTML\r\ndocument.\r\n\r\n```html\r\n<input type=\"file\" id=\"file_input\" webkitdirectory=\"\" directory=\"\"/>\r\n```\r\n\r\nAfter adding a listener to this DOM element we can process the generated event and iterate through the selected files.\r\nThe process of iterating through files and copying them from the user's file system to the HTML5 persistent storage requires\r\na number of steps:\r\n\r\n1. Iterate through all of the selected files\r\n2. For each file download the file from the user's file system\r\n3. Create the directory housing the file within HTML5 persistent storage\r\n4. Save the file to HTML5 persistent storage\r\n\r\nThese steps are done using 4 JavaScript functions\r\n\r\n- `handleFileSelect(evt)`\r\n    - Gets list of selected files\r\n    - Calls `handleFile(file)` to handle the first selected file\r\n- `handleFile(file)`\r\n    - If all files have been loaded, update HTML status and end\r\n    - Gets URL for specified file\r\n    - Checks that the file does not already exists in HTML5 persistent storage\r\n    - Calls `downloadFile(url, success)` with `saveFile(blob, path)` as callback\r\n- `downloadFile(url, success)`\r\n    - Create HTTP request for URL\r\n    - Download blob of URL and pass it to success callback\r\n- `saveFile(blob, path)`\r\n    - Splits path of blob into folders and creates them using `createDir(folders)` if they don't exist\r\n    - Create file and write blob to HTML5 persistent storage\r\n    - Call `handleFile(file)` for the next file in list of selected files\r\n\r\nThe source for these files can be found [here](https://gist.github.com/nicolaslangley/8cecc8294d56d03bab3b)\r\n\r\n#### <a id=\"convertchromeapp\"/> Converting to NaCl Chrome App ####\r\n\r\nIn order to distribute and run your NaCl application outside of the development environment, it is required to package\r\nit as a Chrome Extension (Chrome App).\r\n\r\nHere are some useful links from Google about this process:\r\n\r\n- [Packaged Apps Overview](https://developer.chrome.com/extensions/apps)\r\n- [Distributing a NaCl App](https://developer.chrome.com/native-client/devguide/distributing)\r\n- [How to Package a Chrome App](https://developer.chrome.com/extensions/packaging)\r\n\r\nHere I will outline some of these steps as well as any changes that were required within the source by this process.\r\n\r\nThe main addition that is required in order to create a packaged Chrome Application is the presence of a `manifest.json`\r\nfile that outlines some details about your application. A detailed outline can be found [here](https://developer.chrome.com/extensions/manifest).\r\n\r\nThe `manifest.json` file that I used was quite simple:\r\n\r\n```\r\n{\r\n  \"manifest_version\": 2,\r\n  \"name\": \"GLBenchmark 2.7.0\",\r\n  \"version\": \"1.0\",\r\n\r\n  \"description\": \"Native Client Version of GLBenchmark\",\r\n  \"icons\": {\"128\": \"icon128.png\"},\r\n  \r\n  \"minimum_chrome_version\": \"28\",\r\n  \"offline_enabled\": true,\r\n  \r\n  \"permissions\": [\r\n    \"unlimitedStorage\",\r\n    \"storage\"\r\n  ],\r\n  \"app\": {\r\n    \"launch\": {\r\n      \"local_path\": \"index.html\",\r\n      \"container\": \"panel\"\r\n    }\r\n  }\r\n}\r\n```\r\n\r\nThe `\"container\"` property determines if the Chrome App launches in a new tab or it's own window.\r\n\r\nThe other major change required by using a packaged app was the bundling of assets. In [the previous section](#assetman) I\r\noutlined how assets were copied based on user input. Since all of the data assets are included along with the Chrome App\r\nthere is no need for any user input. The previous method was reliant on the `<input>` tag for the list of data files and\r\nthere is no way to mimic an `<input>` tag programatically. Inorder to get a list of all of the asset files, I was forced to\r\ngenerate a textfile with a list of all of the filenames. This could then be loaded and parsed in the JavaScript to form a\r\nlist of files. The updated JavaScript code can be found [here](https://gist.github.com/nicolaslangley/e290c1da767ea4056c7c).\r\n\r\nHere is a Python script used to generate a text file with all of the filenames stored in the `/data/` directory:\r\n\r\n```python\r\nimport os\r\ncurpath = os.getcwd();\r\n\r\nwith open(\"filelist.txt\", \"w\") as a:\r\n    for path, subdirs, files in os.walk(curpath):\r\n       for filename in files:\r\n         relpath = os.path.relpath(path, curpath); \r\n         if relpath[:4] == \"data\":\r\n           f = os.path.join(relpath, filename)\r\n           a.write(str(f) + os.linesep)\r\n```\r\n\r\nYou can then load Chrome and package your application into a `.crx` which can be distributed (see [link](https://developer.chrome.com/extensions/packaging) above) and installed by other Chrome users.\r\n\r\n#### <a id=\"debuglog\"/> Debugging and Logging ####\r\n\r\nDebugging and logging in Chrome are covered extensively [here](https://developer.chrome.com/native-client/devguide/devcycle/debugging)\r\nbut I will go into some detail about a couple of techniques that I used that were helpful in working on the GLB \r\nexample.\r\n\r\nThe main way of debugging a NaCl app is to use either the included version of `nacl-gdb` that is bundled in the NaCl SDK.\r\nThis can be launched within Visual Studio 2010 if the NaCl plugin is installed (see [Visual Studio section](#vs_tool)) or\r\nfrom the command line by launching Chrome with the `--enable-nacl-debug` flag and then running the `nacl-gdb` executable\r\nfound in the NaCl SDK.\r\n\r\nThis latter process can be made more seamless by loading a script that performs the setup detailed in the linked document\r\nabove. This is done by using the `-x` flag with the name of the script as an argument when running nacl-gdb from the command\r\nline.\r\n\r\nThe script I used was:\r\n\r\n```\r\ntarget remote localhost:4014\r\nnacl-manifest \"GLBenchmark_2_7_0\\projects\\nacl\\newlib\\glbench_nacl_vs10.nmf\"\r\nremote get irt .\\irt.nexe\r\nnacl-irt .\\irt.nexe\r\n```\r\n\r\nWhere the `nacl-manifest` location denotes wherever the `.nmf` file is stored\r\n\r\nWithin the code, and working with OpenGL code specifically, I found that a useful feature of GDB is the ability to\r\ndynamically call global functions while debugging. This is extremely useful for determining the output of `glGetError()` or\r\n`glGetString()` at runtime without having to add unnecessary calls within your code. I simply added the following global\r\nfunctions:\r\n\r\n```cpp\r\n// Global GL functions for debugging\r\nGLenum GetGLError() {\r\n  GLenum error = glGetError();\r\n  return error;\r\n}\r\n\r\nconst GLubyte* GetGLString() {\r\n  const GLubyte* vendor = glGetString(GL_VENDOR);\r\n  return vendor;\r\n}\r\n```\r\n\r\nAnd used the GDB [`call`](https://sourceware.org/gdb/onlinedocs/gdb/Calling.html) function to retrieve the output while\r\ndebugging.\r\n\r\nLogging within your Native Client code can be done by redirecting the `stdout` and `stderr` channels or by using the\r\n`PostMessage()` function within your code. However, `PostMessage()` is a member function of the current instance and so in\r\norder to be able to use `PostMessage()` outside of the instance I had to make a global reference to the instance and \r\naccess it in any other class or function to use `PostMessage()`. This is not as trivial as it sounds and requires passing\r\nan ID of the instance as a `PP_Instance` value.\r\n\r\nWithin the instance class we have to retrieve the `PP_Instance` value:\r\n\r\n```cpp\r\ng_instance = this->pp_instance();\r\n```\r\n\r\nAnd within the class that we want to add access to `PostMessage()` in:\r\n\r\n```cpp\r\npp::Instance cur_instance = pp::Instance(g_instance);\r\ncur_instance.PostMessage(...);\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}